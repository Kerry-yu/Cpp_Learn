>  本阶段主要针对C++**面向对象**编程技术做详细讲解，探讨C++中的核心和精髓

## 1. 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的
+ 全局区：存放全局变量和静态变量以及常量
+ 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
+ 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

### 1.1 程序运行前

在程序编译后，生成了exe的可执行程序，**未执行程序前**分为两个区域

**代码区：**

存放CPU执行的机器指令

代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区：**

全局变量和静态变量存放在此

全局区还包括了常量区，字符串常量和其他常量也存放在此

该区域的数据在程序结束后由操作系统释放

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;

//创建全局变量
int  g_a = 10;
int g_b = 10;
//const修饰的全局变量，全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main()
{
	//创建普通局部变量
	int a = 10;
	int b = 10;

	cout << "局部变量a的地址为：" << (int)&a << endl;
	cout << "局部变量b的地址为：" << (int)&b << endl;

	cout << "全局变量g_a的地址为：" << (int)&g_a << endl;
	cout << "全局变量给g_b的地址为：" << (int)&g_b << endl;

	//静态变量	在普通变量前面加static，属于静态变量
	static int s_a = 10;
	static int s_b = 10;

	cout << "静态变量g_a的地址为：" << (int)&s_a << endl;
	cout << "静态变量给g_b的地址为：" << (int)&s_b << endl;

	//常量
	//字符串常量
	cout << "字符串常量给g_b的地址为：" << (int)&"hello world" << endl;

	//const修饰的变量
	//const修饰的全局变量	  const修饰的局部变量
	cout << "全局常量给c_g_b的地址为：" << (int)&c_g_b << endl;
	cout << "全局常量给c_g_b的地址为：" << (int)&c_g_b << endl;

	int c_l_a = 10;
	cout << "局部常量给c_l_a的地址为：" << (int)&c_l_a << endl;



	return 0;
}
```

**打印结果：**

![image-20210919163744214](https://img.wkeyu.cn/blog/paper/20210919163744.png)

**总结：**

+ C++中在程序运行前分为全局区和代码区
+ 代码区特点是只读和共享
+ 全局区中存放全局变量、静态变量、常量
+ 常量区中存放const修饰的全局常量和字符串常量

### 1.2 程序运行后

**栈区：** 由编译器字符分配释放，存放函数的参数值，局部变量等

注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;

int* func()
{
	int a = 10;
	return &a;
}
int main()
{
	int* p = func();

	cout << *p << endl;
	cout << *p << endl;

	return 0;
}
```

![image-20210919164320110](https://img.wkeyu.cn/blog/paper/20210919164320.png)

**堆区：** 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收，在C++中主要利用new在堆区开辟内存

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;

int* func()
{
	int a = 10;
	return &a;
}
int main()
{
	int* p = func();

	cout << *p << endl;
	cout << *p << endl;

	return 0;
}
```

### 1.3 new操作符

C++中利用**new**操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

语法：`new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针

**示例1：基本语法：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//1.new的基本语法
int* func()
{
	//在堆区创建整型数据
	//new返回是 该数据类型的指针
	int* p = new int(10);
	return p;
}

void test01()
{
	int* p = func();
	cout << *p << endl;
	cout << *p << endl;
	//如果想释放堆区的数据，利用关键字delete
	delete p;

	//cout << *p << endl; 内存已经被释放，再次访问就是非法操作
}
int main()
{
	test01();
	test02();

	return 0;
}
```

 **示例2：开辟数组**

```cpp
//2.在堆区利用new开辟数组
void test02()
{
	//创建10整型数据的数组，在堆区
	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放堆区数组	要加[]
	delete[] arr;
}
```

## 2. 引用

### 2.1 引用的基本使用

**作用：** 给变量起别名

**语法：**`数据类型 &别名 = 原名` 

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

int main()
{
	//引用基本语法
	//数据类型 & 别名=原名
	int a = 10;
	int& b = a;
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;

	b = 100;
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;

	return 0;
}
```

![image-20211029151125362](https://img.wkeyu.cn/blog/paper/20211029151125.png)

 ### 2.2 引用的注意事项

+ 引用必须初始化
+ 引用在初始化后，不可以改变

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;

int main()
{
	int a = 10;
	//1. 引用必须初始化
	int& b = a;

	//2. 引用在初始化后，不可以改变
	int c = 20;
	b = c;//赋值操作，而不是更改引用

	cout << "a=" << a << endl;
	cout << "b=" << b << endl;
	cout << "c=" << c << endl;

	return 0;
}
```

### 2.3 引用做函数参数

**作用：** 函数传参时，可以利用引用的技术让形参修饰实参

**优点：** 可以简化指针修改实参

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//交换函数
//1. 值传递
void mySwap01(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;
}
//2. 地址传递
void mySwap02(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}
//3. 引用传递
void mySwap03(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}
int main()
{
	int a = 10;
	int b = 20;
	//mySwap01(a, b);
	//mySwap02(&a, &b);
	mySwap03(a, b);
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;

	return 0;
}
```

> 通过引用参数产生的效果同按地址传递是一样的，引用的语法更清楚简单

### 2.4 引用做函数返回值

**作用：** 引用是可以作为函数返回值存在的

**注意：** 不要返回局部变量引用

**用法：** 函数调用作为左值

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//引用做函数的返回值 
//1. 不要返回局部变量的引用
int& test01()
{
	int a = 10;//局部变量存放在栈区
	return a;
}
//2. 函数的调用可以作为左值
int& test02()
{
	static int a = 10;//静态变量存放在全局区，程序结束后由系统释放
	return a;
}

int main()
{
	int& ref = test01();
	cout << "ref=" << ref << endl;//第一次结果正确，因为编译器做了保留
	cout << "ref=" << ref << endl;//第二次结果错误，因为a的内存已经释放

	int& ref2 = test02();
	cout << "ref2=" << ref2 << endl;
	cout << "ref2=" << ref2 << endl;

	test02() = 1000;//如果函数的返回值是一个引用，这个函数调用可以作为左值
	cout << "ref2=" << ref2 << endl;
	cout << "ref2=" << ref2 << endl;

	return 0;
}
```

### 2.5 引用的本质

**本质：** 引用其本质在c++内部实现是一个指针常量

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//发现是引用，转换为int *const ref=&a;
void func(int& ref)
{
	ref = 100;//ref是引用，转换为"ref=100"
}

int main()
{
	int a = 10;
	
	//自动转换为 int* const ref =&a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a;
	ref = 20;//内部发现ref是引用，自动帮我们转换为：*ref = 20;
	
	cout << "a:" << a << endl;
	cout << "ref:" << ref << endl;

	func(a);

	return 0;
}
```

**结论：** C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了

### 2.6 常量引用

**作用：** 常量主要是用来修饰形参，防止误操作

在函数形参列表中，可以加=***const修饰形参***，防止形参改变实参

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//常量引用
//使用场景：用来修饰形参，防止误操作

//打印数据函数
void showValue(const int& val)
{
	cout << "val=" << val << endl;
}

int main()
{

	int a = 10;
	//int& ref = 10;//引用必须引一块合法的空间
	//加上const之后，编译器将代码修改 int temp=10; const int& ref = temp;
	const int& ref = 10;
	//ref = 20;//加入const之后变为只读，不可以修改
	int a = 100;
	showValue(a);

	return 0;
}
```

## 3. 函数提高

### 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的

**语法：**`返回值类型 函数名 （参数=默认值）{}`

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//函数默认参数
int func(int a, int b = 20, int c = 30)
{
	return a + b + c;
}
//注意事项
//1. 如果某个位置已经有了默认参数，那么从这个位置之后，从左到右都必须有默认值
//int func2(int a = 10, int b, int c)
//{
//	return a + b + c;
//}
//2. 函数声明和函数实现只能有一个有默认参数
int func2(int a = 10, int b = 20);
int func2(int a, int b)
{
	return a + b;
}

int main()
{
	//若自己传入数据，就用自己的；若没传数据，就用默认的
	cout << func(10) << endl;
	cout << func(10, 30) << endl;

	return 0;
}
```

注意事项：

+ 若自己给函数传入数据，就用自己的；若没传数据，就用默认的

+ 如果某个位置已经有了默认参数，那么从这个位置之后，从左到右都必须有默认值
+ 函数声明和函数实现只能有一个有默认参数

### 3.2 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

**语法：**`返回值类型 函数名 (数据类型){}`

在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术

**示例：**

```cpp
//函数占位参数，占位参数也可以有默认参数
#include<iostream>
#include<string>

using namespace std;
//占位参数
//占位参数 还可以有默认参数
void func(int a,int =10)
{
	cout << "this is func" << endl;
} 
int main()
{
	func(10,10);

	return 0;
}
```

### 3.3 函数重载

 #### 3.3.1 函数重载概述

**作用：** 函数名可以相同，提高复用性

**函数重载满足条件：**

+ 同一个作用域下
+ 函数名称相同
+ 函数参数**类型不同** 或者**个数不同**或者**顺序不同**

**注意：** 函数的返回值不可以作为函数重载的条件

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//函数重载
//可以让函数名相同，提高复用性

//函数重载的满足条件
//1. 同一个作用域下
//2. 函数名称不同
//3. 函数参数类型不同，或者个数不同，或者顺序不同
void func()
{
	cout << "func的调用" << endl;
}
void func(int a)
{
	cout << "func(int a)的调用!" << endl;
}
void func(double a)
{
	cout << "func(double a)的调用!!" << endl;
}
 
int main()
{
	func(10);
	func(3.14);

	return 0;
}
```

### 3.3.2 函数重载注意事项

+ 引用作为重载条件
+ 函数重载碰到函数默认参数

**示例：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//函数重载的注意事项
//1. 引用作为重载的条件
void func(int &a)
{
	cout << "fun(int &a)调用" << endl;
}
void func(const int& a)
{
	cout << "fun(const int &a)调用" << endl;
}
//2. 函数重载碰到默认参数
void func2(int a,int b=10)
{
	cout << "fun2(int a)调用" << endl;
}
void func2(int a)
{
	cout << "fun2(int a)调用" << endl;
}

int main()
{
	int a = 10;
	func(a);//fun(int &a)调用
	func(10);//fun(const int &a)调用

	return 0;
}
```

## 4. 类和对象

C++面向对象的三大特性为：***封装、继承、多态***

C++认为万事万物皆为对象，对象上有其属性和行为

### 4.1 封装

#### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

+ 将属性和行为作为一个整体，表现生活中的事物
+ 将属性和行为加以权限控制

**封装意义一：**

​	在设计类的时候，属性和行为写在一起，表现事物

**语法：**`class 类名{ 访问权限：属性 / 行为}`

**示例1：** 设计一个圆类，求圆的周长

**代码：**

```cpp
#include<iostream>
#include<string>

using namespace std;
//设计一个圆类，求圆的周长
const double PI = 3.14;

class Circle
{
	//访问权限
public://公共权限

	//属性
	int m_r;//半径

	//行为
	double calculateZC()//获取圆的周长
	{
		return 2 * PI * m_r;
	}
};
int main()
{
	//通过圆类 创建具体的圆（对象）
	Circle c1;
	//给圆对象的属性进行赋值
	c1.m_r = 10;

	cout << "圆周长为：" << c1.calculateZC() << endl;

	return 0;
}
```

**示例2：** 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

```cpp
#include<iostream>
#include<string>
using namespace std;

//设计一个学生类，属性有姓名和学号
//可以给姓名和学号赋值，可以显示学生的姓名和学号

//设计学生类
class student
{
public:	//公共权限
	//类中的属性和行为 统一称为成员
	//属性	成员属性	成员变量
	//行为	成员函数	成员方法

	//属性
	string m_Name;//姓名
	int m_Id;//学号

	//行为
	//显示姓名和学号
	void showStudent()
	{
		cout << "姓名:" << m_Name << "\t 学号：" << m_Id << endl;
	}
	//给姓名赋值
	void setName(string name)
	{
		m_Name = name;
	}
	//给学号赋值
	void setId(int id)
	{
		m_Id = id;
	}
};
int main()
{
	//实例化对象
	student s1;
	//给s1对象进行属性赋值操作
	s1.setName("张三");
	s1.setId(1);
	//显示学生信息
	s1.showStudent();

	return 0;
}
```

>  注：类中的属性和行为 统一称为成员
>  		属性又称为成员属性或成员变量
>  		行为又称为成员函数或成员方法

**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public  公共权限
2. protected   保护权限
3. private   私有权限

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//访问权限	三种			
//公共权限	public		成员		类内可以访问，类外也可以访问
//保护权限	protected	成员		类内可以访问，类外不可以访问
//私有权限	private		成员		类内可以访问，类外不可以访问

class Person
{
public:
	//公共权限
	string m_Name;

protected:
	//保护权限
	string m_Car;

private:
	//私有权限
	int m_Password;

public:
	void func()
	{
		m_Name = "张三";
		m_Car = "宝马";
		m_Password = 123456;
	}
};
int main()
{
	Person p1;
	p1.m_Name = "李四";
	//p1.m_Car = "奔驰";

	return 0;
}
```

 #### 4.1.2 struct和class的区别

在C++中struct和class唯一的区别就在于 **默认的访问权限不同**

区别：

+ struct的默认权限为公共
+ class的默认权限为私有

```cpp
#include<iostream>
#include<string>
using namespace std;

class C1
{
	int m_A;//默认权限	private
};

struct C2
{
	int m_A;//默认权限	public
};
int main()
{
	C2 c2;
	c2.m_A = 100;

	return 0;
}
```

#### 4.1.3 成员属性设置为私有

**优点1：** 将所有成员属性设置为私有，可以控制自己读写权限

**优点2：** 对于写权限，我们可以检测数据的有效性

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	//设置姓名
	void setName(string name)
	{
		m_Name = name;
	}
	//获取姓名
	string getName()
	{
		return m_Name;
	}
	//获取年龄
	int getAge()
	{
		m_Age = 0;
		return m_Age;
	}
	//设置爱人
	void setLover(string lover)
	{
		m_Lover = lover;
	}

private:
	string m_Name;//姓名		可读可写
	int m_Age;//年龄		只读
	string m_Lover;//爱人	只写
};
int main()
{
	Person p;
	p.setName("张三");
	cout << "姓名为：" << p.getName() << endl;
	cout << "年龄为：" << p.getAge() << endl;
	p.setLover("xxx");

	return 0;
}
```

**练习案例1：设计立方体类**

设计立方体类（Cube）

求出立方体的面积和体积

分别用全局函数和成员函数判断两个立方体是否相等

**代码：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//立方体类设计
//1. 创建立方体类
//2. 设计属性和行为
//3. 获取立方体面积和体积
//4. 分别利用全局函数和成员函数判断两个立方体是否相等
class Cube
{
public:
	//设置长
	void setL(int l)
	{
		m_L = l;
	}
	//获取长
	int getL()
	{
		return m_L;
	}
	//设置宽
	void setW(int w)
	{
		m_W = w;
	}
	//获取宽
	int getW()
	{
		return m_W;
	}
	//设置高
	void setH(int h)
	{
		m_H = h;
	}
	//获取高
	int getH()
	{
		return m_H;
	}
	//获取立方体面积
	int cubeS()
	{
		return 2 * m_L * m_W + 2 * m_L * m_H + 2 * m_W * m_H;
	}
	//获取立方体体积
	int cubeV()
	{
		return m_L * m_W * m_H;
	}

	//利用成员函数判断 两个立方体是否相等
	bool isSameByClass(Cube& c)
	{
		if (m_L == c.getL() && m_W == c.getW() && m_H == c.getH())
		{
			return true;
		}
		else
			return false;
	}

private:
	int m_L;
	int m_W;
	int m_H;
};
//利用全局函数判断 两个立方体是否相等
bool isSame(Cube& c1, Cube& c2)
{
	if (c1.getL() == c2.getL() && c1.getW() == c2.getW() && c1.getH() == c2.getH())
	{
		return true;
	}
	else
		return false;
}

int main()
{
	//创建立方体对象
	Cube c1;
	c1.setL(10);
	c1.setW(10);
	c1.setH(10);

	cout << "c1的面积为：" << c1.cubeS() << endl;
	cout << "c1的体积为：" << c1.cubeV() << endl;

	//创建第二个立方体
	Cube c2;
	c2.setL(10);
	c2.setW(10);
	c2.setH(10);

	//利用全局函数判断
	bool ret = isSame(c1, c2);
	if (ret)
	{
		cout << "c1和c2是相等的" << endl;
	}
	else
	{
		cout << "c1和c2是不相等的" << endl;

	}

	//利用成员函数判断
	bool ret2 = c1.isSameByClass(c2);
	if (ret2)
	{
		cout << "c1和c2是相等的" << endl;
	}
	else
	{
		cout << "c1和c2是不相等的" << endl;

	}
	return 0;
}
```

**练习案例2：点和圆的关系**

设计一个圆形类（Circle），和另一个点类（Point），计算点和圆的关系。

**代码：**

```cpp
#include<iostream>
#include<string>
using namespace std;
//点和圆关系案例
//点类
class Point
{
public:
	//设置x
	void setX(int x)
	{
		m_X = x;
	}
	//获取x
	int getX()
	{
		return m_X;
	}
	//设置y
	void setY(int y)
	{
		m_Y = y;
	}
	//获取y
	int getY()
	{
		return m_Y;
	}
private:
	int m_X;
	int m_Y;
};
//圆类
class Circle
{
public:
	//设置半径
	void setR(int r)
	{
		m_R = r;
	}
	//获取半径
	int getR()
	{
		return m_R;
	}
	//设置圆心
	void setCenter(Point center)
	{
		m_Center = center;
	}
	//获取圆心
	Point getCenter()
	{
		return m_Center;
	}
private:
	int m_R;//半径
	Point m_Center;//圆心
};

//判断点和圆关系
void isInCircle(Circle& c, Point& p)
{
	//计算两点之间距离的平方
	int distance =
		(c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
		(c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());
	//计算半径的平方
	int rDistance = c.getR() * c.getR();

	//判断关系
	if (distance == rDistance)
	{
		cout << "点在圆上" << endl;
	}
	else if (distance > rDistance)
	{
		cout << "点在圆外" << endl;
	}
	else
	{
		cout << "点在圆内" << endl;
	}
}
int main()
{
	//创建圆
	Circle c;
	c.setR(10);
	Point center;
	center.setX(10);
	center.setY(0);
	c.setCenter(center);
	//创建点
	Point p1;
	Point p2;
	Point p3;
	p1.setX(10);
	p1.setY(10);
	p2.setX(10);
	p2.setY(9);
	p3.setX(10);
	p3.setY(11);

	//判断
	isInCircle(c, p1);
	isInCircle(c, p2);
	isInCircle(c, p3);
	return 0;
}
```

> 1. 在一个类中可以让另一个类 作为本类中的成员
> 2. 可以把一个类拆到不同的文件中，如下例

**point.h:**

```cpp
#pragma once
#include <iostream>
using namespace std;
//点类
class Point
{
public:	
 	//设置x	
    void setX(int x);	
    //获取x	
    int getX();	
    //设置y	
    void setY(int y);	
    //获取y	
    int getY();
private:	
    int m_X;	
    int m_Y;
};
```

**point.cpp:**

```cpp
#include"point.h"
//设置xvoid 
Point:: setX(int x)
{	
    m_X = x;
}
//获取xint 
Point:: getX()
{	
    return m_X;
}
//设置yvoid 
Point:: setY(int y)
{	
    m_Y = y;
}
//获取yint 
Point:: getY()
{	
    return m_Y;
}
```

### 4.2 对象的初始化和清理

+ C++中的面向对象来源于生活，每个对象也都会有初识设置以及 对象销毁前的清理数据的设置

#### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全性问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

C++利用了**构造函数**和**析构函数**解决了上述问题，这两个函数将会被编译器自动调用， 完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供，编译器提供的构造和析构函数是空实现**

+ 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
+ 析构函数：主要作用在于对象销毁系统前自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象的时候会自动调用构造，无需手动调用，而且只会调用一次。

**析构函数语法：**`~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;
//对象的初始化和清理

class Person
{
public:
	//1. 构造函数 进行初始化操作
	Person()
	{
		cout << "Person的构造函数的调用" << endl;
	}
	//2. 析构函数 进行清理的操作
	~Person()
	{
		cout << "Person的析构函数的调用" << endl;
	}
};
void test01()
{
	Person p;//在栈上的数据，test01执行完毕后，释放这个对象
}

int main()
{
	test01();

	return 0;
}
```

#### 4.2.2 构造函数的分类及调用

两种分类方式：

+ 按参数分为：有参构造和无参构造

+ 按类型分为：普通构造和拷贝构造

三种调用方式：

+ 括号法
+ 显示法
+ 隐式转换法

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//构造函数的分类和调用
//分类
class Person
{
public:
	//构造函数
	Person()
	{
		cout << "Person的构造函数调用" << endl;
	}
	Person(int a)
	{
		cout << "Person的构造函数调用" << endl;
	}
	//拷贝构造函数
	Person(const Person& p)
	{
		//将传入的人身上的所有属性，拷贝到该人身上
		age = p.age;
	}
	//析构函数
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

public:
	int age = 0;
};

//调用
void test01()
{
	//1. 括号法
	Person p1;//默认构造函数调用
	Person p2(10);//有参构造函数
	Person p3(p2);//有参构造函数
	//注意事项一
	//调用默认构造函数时，不要加（）
	//因为编译器会把 Person p() 当初函数声明，不会认为在创建对象

	/*cout << "p2的年龄为：" << p2.age << endl;
	cout << "p3的年龄为：" << p3.age << endl;*/

	//2. 显示法
	Person p4;
	Person p5 = Person(10);//有参构造
	Person p6 = Person(p2);//拷贝构造

	Person(10);//匿名对象。特点：当前行执行结束后，系统会立即回收掉匿名对象
	//注意事项二：
	//不要用拷贝构造函数初始化一个匿名对象		编译器会认为Person(p3) == Person p3

	//3. 隐式转换法
	Person p7 = 10;//相当于写了Person p4 = Person(10)
	Person p8 = p7;//拷贝构造

}
int main()
{

	return 0;
}
```

#### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

+ 使用一个已经创建完毕的对象来初始化一个新对象
+ 值传递的方式给函数参数传值
+ 以值方式返回局部对象

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	Person()
	{
		cout << "Person的默认构造函数调用" << endl;
	}

	Person(int age)
	{
		cout << "Person的有参构造函数调用" << endl;
		m_Age = age;
	}

	Person(const Person& p)
	{
		m_Age = p.m_Age;
		cout << "Person的拷贝构造函数调用" << endl;
	}

	~Person()
	{
		cout << "Person的析构函数调用" << endl;

	}

public:
	int m_Age;
};
//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
	Person p1(20);
	Person p2(p1);

	cout << "P2的年龄为:" << p2.m_Age << endl;
}
//2. 值传递的方式给函数的参数传值
void doWork(Person p)
{

}
void test02()
{
	Person p;
	doWork(p);
}
//3. 值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int*)&p1 << endl;
	return p1;
}
void test03()
{
	Person p = doWork2();
	cout << (int*)&p << endl;
}
int main()
{
	test01();
	test03();
	return 0;
}
```

#### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

+ 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
+ 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	Person()
	{
		cout << "Person的默认构造函数的调用" << endl;
	}

	Person(int age)
	{
		cout << "Person的有参构造函数的调用" << endl;
		m_Age = age;
	}

	/*person(const person& p)
	{
		cout << "person的拷贝构造函数的调用" << endl;
		m_age = p.m_age;
	}*/

	~Person()
	{

	}

	int m_Age;
};

void test01()
{
	Person p;
	p.m_Age = 18;

	Person p2(p);

	cout << "p2的年龄为：" << p2.m_Age << endl;
}
int main()
{
	test01();

	return 0;
}
```

#### 4.2.5 深拷贝与浅拷贝

深浅拷贝是经典问题

+ 浅拷贝：简单的赋值操作
+ 深拷贝：在堆区申请空间，进行拷贝操作

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	Person()
	{
		cout << "Person的默认构造函数调用" << endl;
	}

	Person(int age, int height)
	{
		cout << "Person的有参构造函数调用" << endl;
		m_Age = age;
		m_Height = new int(height);
	}

	//自己实现拷贝构造函数，解决浅拷贝问题
	Person(const Person& p)
	{
		cout << "Person的拷贝构造函数调用" << endl;
		m_Age = p.m_Age;
		//m_Height = p.m_Height;//编译器默认实现的拷贝构造函数，会导致指向同一片内存空间

		//深拷贝操作
		m_Height = new int(*p.m_Height);
	}

	~Person()
	{
		//析构代码，将堆区开辟的数据释放
		if (m_Height != NULL)
		{
			delete m_Height;
			m_Height = NULL;
		}
		cout << "Person的析构函数调用" << endl;
	}

public:
	int m_Age;
	int* m_Height;
};

//浅拷贝问题——堆区内存重复释放
void test01()
{
	Person p1(18, 160);
	cout << "p1的年龄为：" << p1.m_Age << "  身高为" << *p1.m_Height << endl;
	Person p2(p1);
	cout << "p2的年龄为：" << p2.m_Age << "  身高为" << *p2.m_Height << endl;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029103926216](https://img.wkeyu.cn/blog/paper/20211029103926.png)

> 总结：如果属性有在堆区开辟的，一定要提供拷贝构造函数，防 止浅拷贝带来的问题

#### 4.2.6 初始化列表

**作用：** C++提供了初始化列表语法，用来初始化属性

**语法：**`构造函数(): 属性1(值1)，属性2(值2) ... {}`

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;
class Person
{
public:
	//传统初始化操作，在构造函数中初始化
	/*Person(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}*/

	//初始化列表初始化属性
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c)
	{

	}
public:
	int m_A;
	int m_B;
	int m_C;
};

void test01()
{
	Person p(10, 20, 30);

	cout << "m_A= " << p.m_A << endl;
	cout << "m_B= " << p.m_B << endl;
	cout << "m_C= " << p.m_C << endl;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029104916441](https://img.wkeyu.cn/blog/paper/20211029104916.png)

#### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为对象成员

例如：

```cpp
class A{}
class B
{
    A a;
}
```

B类中有对象A作为成员，A为对象成员

那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

+ **构造顺序：** 当其他类对象作为本类成员，构造时候先构造类对象，再构造自身
+ **析构顺序：** ***与构造顺序相反***

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;
class Phone
{
public:
	Phone(string pName)
	{
		cout << "Phone的构造函数调用" << endl;
		m_PName = pName;
	}
	~Phone()
	{
		cout << "Phone的析构函数调用" << endl;
	}
public:
	string m_PName;
};

class Person
{
public:
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout << "Person的构造函数调用" << endl;
	}
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}
public:
	string m_Name;
	Phone m_Phone;
};
void test01()
{
	Person p("张三", "苹果手机");
	cout << p.m_Name << "拿着" << p.m_Phone.m_PName << endl;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029110354519](https://img.wkeyu.cn/blog/paper/20211029110354.png)

#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

+ 静态成员变量
  + 所有对象共享同一份数据
  + 在编译阶段分配内存
  + 类内声明，类外初始化
+ 静态成员函数
  + 所有对象共享同一个函数
  + 静态成员只能访问静态成员变量

**示例1：** 静态成员变量

```cpp
#include<iostream>
#include<string>
using namespace std;

//静态成员函数
//所有对象共享同一个函数
//静态成员函数只能访问静态成员变量

class Person
{
public:
	//静态成员函数
	static void func()
	{
		m_A = 100;//静态成员函数可以访问静态成员变量
		//m_B = 200;//静态成员函数不可以访问非静态成员变量，无法区分到底是哪个对象的m_B
		cout << "static void func调用 " << endl;
	}
	//静态成员函数也是有访问权限的
private:
	static void func2()
	{
		cout << "static void func2的调用" << endl;
	}

public:
	static int m_A;//静态成员变量
	int m_B;
};

//两种访问方式
void test01()
{
	//1. 通过对象访问
	Person p;
	p.func();

	//2. 通过类名访问
	Person::func();

	//Person::func2();//类外无法访问私有权限
}
int main()
{
	test01();

	return 0;
}
```

### 4.3 C++对象模型和this指针

#### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

***只有非静态成员变量才属于类的对象上***

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
	int m_A;//非静态成员变量	属于类的对象上
	static int m_B;//静态成员变量		不属于类的对象上
	void func(){}//非静态成员函数		不属于类的对象上
	static void func2(){}//静态成员函数	不属于类的对象上
};

void test01()
{
	Person p;
	//空对象占用的内存空间：1
	//C++编译器会为每个空对象也分配1个字节空间，是为了区分空对象占内存的位置
	//每个空对象应该有一个独一无二的位置
	cout << "size of p:" << sizeof(p) << endl;
}

void test02()
{
	Person p;
	cout << "size of p:" << sizeof(p) << endl;

}
int main()
{
	//test01();
	test02();

	return 0;
}
```

> 注意：空对象占用的内存空间：1

#### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：  这一块的代码是如何区分那个对象调用自己的呢？

C++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途：

+ 当形参和成员变量同名时，可以用this指针来区分
+ 在类的非静态成员函数中返回对象本身，可以使用return *this

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	Person(int age)
	{
		this->age = age;
	}
	Person& PersonAddAge(Person& p)
	{
		this->age += p.age;

		//this是指向p2的指针，*this指向的就是p2这个对象本体
		return *this;
	}

	int age;
};
//1. 解决名称冲突
void test01()
{
	Person p1(18);
	cout << "p1的年龄为：" << p1.age << endl;
}

//2. 返回对象本身用*this
void test02()
{
	Person p1(10);

	Person p2(10);

	//链式编程思想
	p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);

	cout << "p2的年龄为：" << p2.age << endl;

}

int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211029153202200](https://img.wkeyu.cn/blog/paper/20211029153202.png)

#### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//空指针调用成员函数
class Person
{
public:
	void showClassName()
	{
		cout << "this is Person class" << endl;
	}
	void showPersonAge()
	{
		//报错原因是因为传入指针为控
		if (this == NULL)
		{
			return;
		}
		cout << "age=" << m_Age << endl;//m_Age实际为this->m_Age
	}

	int m_Age;
};

void test01()
{
	Person* p = NULL;

	p->showClassName();
	p->showPersonAge();

}
int main()
{
	return 0;
}
```

#### 4.3.4 const修饰成员函数

**常函数：**

+ 成员函数后加const后我们称这个函数为**常函数**
+ 常函数内不可以修改成员属性
+ 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象：**

+ 声明对象前加const称该对象为常对象
+ 常对象只能调用常函数

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;
//常函数
class Person
{
public:
	//this指针的本质	是指针常量	指针的指向是不可以修改的
	//const Person *const this
	//在成员函数后面加const，修饰的是this指针（即上面第一个const），让指针指向的值也不可以修改
	void showPerson() const
	{
		//m_A = 100;
		m_B = 100;
	}
	void func()
	{

	}

	int m_A;
	mutable int m_B;//特殊变量，即使在常函数中，该值也可以修改
};

void test01()
{
	Person p;
	p.showPerson();
}

//常对象
void test02()
{
	const Person p;//在对象前加const，变为常对象
	//p.m_A = 100;
	p.m_B = 100;//m_B是特殊值，在常对象下也可以修改

	//常对象只能调用常函数
	p.showPerson();
	//p.func();常对象不允许修改成员属性，而普通成员函数却能修改成员属性
}

int main()
{
	return 0;
}
```

### 4.4 友元

在程序里，有些私有属性 也想让类外特殊的一些函数或类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元关键字为***friend***

友元的三种实现

+ 全局函数做友元
+ 类做友元
+ 成员函数做友元

#### 4.4.1 全局函数做友元

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Building
{
	//goodFriend全局函数是类Building的好朋友，可以访问私有成员
	friend void goodFriend(Building* building);

public:
	Building()
	{
		m_Sittingroom = "客厅";
		m_Bedroom = "卧室";
	}
public:
	string m_Sittingroom;

private:
	string m_Bedroom;
};

//全局函数
void goodFriend(Building* building)
{
	cout << "好朋友全局函数 正在访问：" << building->m_Sittingroom << endl;
	cout << "好朋友全局函数 正在访问：" << building->m_Bedroom << endl;
}

void test01()
{
	Building building;
	goodFriend(&building);
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029170852891](https://img.wkeyu.cn/blog/paper/20211029170852.png)

  #### 4.4.2 类做友元

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//类做友元
class Building
{
	//GoodFriend是本类的好朋友，可以访问该类的私有成员
	friend	class GoodFriend;
public:
	Building()
	{
		m_Sittingroom = "客厅";
		m_Bedroom = "卧室";
	}

public:
	string m_Sittingroom;

private:
	string m_Bedroom;
};

class GoodFriend
{
public:
	GoodFriend()
	{
		building = new Building;
	}
	void visit()
	{
		cout << "好朋友全局函数 正在访问：" << building->m_Sittingroom << endl;
		cout << "好朋友全局函数 正在访问：" << building->m_Bedroom << endl;
	}

public:
	Building* building;
};



void test01()
{
	GoodFriend gg;
	gg.visit();
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029171947803](https://img.wkeyu.cn/blog/paper/20211029171947.png)

#### 4.4.3 成员函数做友元

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Building;
class GoodFriend
{
public:
	GoodFriend();
	void visit();//让visit函数可以访问Building的私有成员
	void visit02();//让visit02不能访问Building的私有成员

public:
	Building* building;

};

class Building
{
	//告诉编译器 GoodFriend类下的visit成员函数作为本类的好朋友，可以访问该类的私有成员
	friend void GoodFriend::visit();
public:
	Building();

public:
	string m_Sittingroom;

private:
	string m_Bedroom;

};

Building::Building()
{
	m_Sittingroom = "客厅";
	m_Bedroom = "卧室";
}

void GoodFriend::visit()
{
	cout << "visit函数正在访问：" << building->m_Sittingroom << endl;
	cout << "visit函数正在访问：" << building->m_Bedroom << endl;
}

void GoodFriend::visit02()
{
	cout << "visit02函数正在访问：" << building->m_Sittingroom << endl;
	//cout << "visit02函数正在访问：" << building->m_Bedroom << endl;
}

GoodFriend::GoodFriend()
{
	building = new Building;
}

void test01()
{
	GoodFriend ff;
	ff.visit();
	ff.visit02();
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029173235234](https://img.wkeyu.cn/blog/paper/20211029173235.png)

### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算

```cpp
#include<iostream>
#include<string>
using namespace std;

//加号运算符重载
class Person
{
public:
	//1. 成员函数重载+号
	/*Person operator+(Person& p)
	{
		Person temp;
		temp.m_A = this->m_A + p.m_A;
		temp.m_B = this->m_B + p.m_B;
		return temp;
	}*/
public:
	int m_A;
	int m_B;
};

//2. 全局函数重载+号
Person operator+(Person& p1, Person& p2)
{
	Person temp;
	temp.m_A = p1.m_A + p2.m_A;
	temp.m_B = p1.m_B + p2.m_B;
	return temp;
}

//函数重载的版本
Person operator+(Person& p1, int num)
{
	Person temp;
	temp.m_A = p1.m_A + num;
	temp.m_B = p1.m_B + num;
	return temp;
}

void test01()
{
	Person p1;
	p1.m_A = 10;
	p1.m_B = 10;
	Person p2;
	p2.m_A = 10;
	p2.m_B = 10;

	Person p3 = p1 + p2;

	//运算符重载，也可以发生函数重载
	Person p4 = p1 + 100;

	cout << "p3.m_A=" << p3.m_A << endl;
	cout << "p3.m_B=" << p3.m_B << endl;
	cout << "p4.m_A=" << p4.m_A << endl;
	cout << "p4.m_B=" << p4.m_B << endl;
}

int main()
{
	test01();

	return 0;
}
```

![image-20211029175222121](https://img.wkeyu.cn/blog/paper/20211029175222.png)

> 总结1：对于内置的数据类型的表达式的运算符是不可能发生改变的
>
> 总结2：不要滥用运算符重载

#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

```cpp
#include<iostream>
#include<string>
using namespace std;

//左移运算符重载
class Person
{
	friend ostream& operator<<(ostream& cout, Person& p);
public:
	//利用成员函数重载 左移运算符
	//不会利用成员函数重载<< 运算符，因为无法实现cout在左侧
	/*void operator<<(cout)
	{

	}*/
	Person(int a, int b)
	{
		m_A = a;
		m_B = b;
	}

private:
	int m_A;
	int m_B;
};

//只能利用全局函数重载左移运算符
ostream& operator<<(ostream& cout, Person& p)
{
	cout << "m_A=" << p.m_A << "  m_B=" << p.m_B;
	return cout;
}
void test01()
{
	Person p(10, 10);

	cout << p << endl;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029190925218](https://img.wkeyu.cn/blog/paper/20211029190925.png)

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

#### 4.5.3 递增运算符重载

作用：通过重载递增运算符，实现自己的数据类型

```cpp
#include<iostream>
#include<string>
using namespace std;

//重载递增运算符

//自定义整型
class MyInteger
{
	friend ostream& operator<<(ostream& cout, MyInteger myint);
public:
	MyInteger()
	{
		m_Num = 0;
	}

	//重载前置++运算符
	MyInteger& operator++()
	{
		m_Num++;//先进行++运算
		return *this;//在返回自身
	}
	//重载后置++运算符	int代表占位参数，可以区分前置和后置递增（函数重载）
	MyInteger operator++(int)
	{
		//先记录当时结果
		MyInteger temp = *this;
		//再进行++运算
		m_Num++;
		//返回记录结果
		return temp;
	}

private:
	int m_Num;
};

//重载<<运算符
ostream& operator<<(ostream& cout, MyInteger myint)
{
	cout << myint.m_Num;
	return cout;
}

void test01()
{
	MyInteger myint;
	cout << ++(++myint) << endl;
	cout << myint << endl;
}

void test02()
{
	MyInteger myint;
	cout << myint++ << endl;
	cout << myint << endl;
}
int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211029192630412](https://img.wkeyu.cn/blog/paper/20211029192630.png)

> 总结： 前置递增返回引用，后置地递增返回值

#### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数（无参，函数体为空）

2. 默认析构函数（无参，函数体为空）

3. 默认拷贝构造函数，对属性进行值拷贝

4. 赋值运算符operator=。对属性进行值拷贝

5. 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
	Person(int age)
	{
		m_Age = new int(age);
	}
	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//重载 赋值运算符
	Person& operator=(Person& p)
	{
		//编译器提供浅拷贝
		//m_Age=p.m_Age;

		//应该先判断是否有属性在堆区，如果有，先释放干净，然后再深拷贝
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}

		//深拷贝
		m_Age = new int(*p.m_Age);

		//返回对象本身
		return *this;
	}
public:
	int* m_Age;
};

void test01()
{
	Person p1(18);
	Person p2(20);
	Person p3(30);

	p3 = p2 = p1;

	cout << "p1的年龄为：" << *p1.m_Age << endl;
	cout << "p2的年龄为：" << *p2.m_Age << endl;
	cout << "p3的年龄为：" << *p3.m_Age << endl;
}
int main()
{
	test01();

	return 0;
}
```

   ![image-20211029194249801](https://img.wkeyu.cn/blog/paper/20211029194249.png)

#### 4.5.5 关系运算符重载

**作用：** 重载关系运算符，可以让两个自定义类型对象进行对比操作

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//重载关系运算符
class Person
{
public:
	Person(string name, int age)
	{
		m_Name = name;
		m_Age = age;
	}

	//重载 == 号
	bool operator==(Person& p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return true;
		}
		else
			return false;
	}
	bool operator!=(Person& p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return false;
		}
		else
			return true;
	}

public:
	string m_Name;
	int m_Age;
};

void test01()
{
	Person p1("Tom", 18);
	Person p2("Tom", 18);

	if (p1 == p2)
	{
		cout << "p1和p2是相等的" << endl;
	}
	else
	{
		cout << "p1和p2是不相等的" << endl;
	}
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029195401143](https://img.wkeyu.cn/blog/paper/20211029195401.png)

#### 4.5.6 函数调用运算符重载

+ 函数调用运算符()也可以重载
+ 由于重载后使用的方式非常像函数的调用，因此称为仿函数
+ 仿函数没有固定写法，非常灵活

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//函数调用运算符重载

//打印输出类
class MyPrint
{
public:
	//重载函数调用运算符
	void operator()(string test)
	{
		cout << test << endl;
	}
};

void test01()
{
	MyPrint myprint;
	myprint("Hello World!");
}
//仿函数非常灵活，没有固定的写法
//加法类
class Myadd
{
public:
	int operator()(int num1, int num2)
	{
		return num1 + num2;
	}
};

void test02()
{
	Myadd myadd;
	int ret = myadd(100, 100);
	cout << "ret=" << ret << endl;

	//匿名函数对象
	cout << Myadd()(100, 100) << endl;
}
int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211029200105214](https://img.wkeyu.cn/blog/paper/20211029200105.png)

### 4.6 继承

**继承是面向对象三大特性之一**

![image-20211029201010525](https://img.wkeyu.cn/blog/paper/20211029201010.png)

 有些类，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码

### 4.6 继承

**继承是面向对象三大特性之一**

![image-20211029201010525](https://img.wkeyu.cn/blog/paper/20211029201142.png)

 有些类，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码

#### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。

接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处

**普通实现：**

 ```cpp
#include<iostream>
#include<string>
using namespace std;

//普通实现页面
//java页面
class Java
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图（公共底部）" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++（公共侧边）" << endl;
	}
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};
//Python页面
class Python
{
	 ...
};

void test01()
{
	cout << "Java下载视频页面如下：" << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
}
int main()
{
	test01();

	return 0;
}
 ```

**继承实现：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//普通实现页面
//java页面
//class Java
//{
//public:
//	void header()
//	{
//		cout << "首页、公开课、登录、注册(公共头部)" << endl;
//	}
//	void footer()
//	{
//		cout << "帮助中心、交流合作、站内地图（公共底部）" << endl;
//	}
//	void left()
//	{
//		cout << "Java、Python、C++（公共侧边）" << endl;
//	}
//	void content()
//	{
//		cout << "Java学科视频" << endl;
//	}
//};
////Python页面
//class Python
//{
//	 
//};

//继承实现页面
//公共页面
class Basepage
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图（公共底部）" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++（公共侧边）" << endl;
	}
};

//java页面
class java : public Basepage
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};
//python页面
class python :public Basepage
{
public:
	void content()
	{
		cout << "python学科视频" << endl;
	}
};
//c++页面
class cpp :public Basepage
{
public:
	void content()
	{
		cout << "cpp学科视频" << endl;
	}
};
```

**总结：**

继承的好处：***可以减少重复的代码***

继承语法：`class A : public B`

A称为子类 或 派生类

B称为父类 或 基类

**子类中的成员，包含两大部分：**

一类是从父类中继承过来的，一类是自己增加的成员

从基类继承过来的表现其共性，而新增的成员体现了其个性

 #### 4.6.2 继承方式

继承的语法：`class 子类 : 继承方式 父类`

**继承方式一共有三种：**

+ 公共继承	public
+ 保护继承    protected
+ 私有继承    private

![image-20211029203454979](https://img.wkeyu.cn/blog/paper/20211029203455.png)

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//继承方式
class Base1
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Base2
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Base3
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

//公共继承
class Son1 :public Base1
{
public:
	void func()
	{
		m_A = 10;
		m_B = 10;
		//m_C = 10;
	}
};
void test01()
{
	Son1 son1;
	son1.m_A = 100;
	son1.m_B = 100;
	son1.m_C = 100;
}

//保护继承
class Son2 :protected Base2
{
public:
	void func()
	{
		m_A = 10;
		m_B = 10;
		//m_C = 10;
	}
};
void test02()
{
	Son2 son2;
	son2.m_A = 100;
	son2.m_B = 100;
	son2.m_C = 100;
}

//私有继承
class Son3 :private Base3
{
public:
	void func()
	{
		m_A = 10;
		m_B = 10;
		//m_C = 10;
	}

};
void test03()
{
	Son3 son3;
	son3.m_A = 100;
	son3.m_B = 100;
	son3.m_C = 100;
}

int main()
{
	test01();
	test02();
	test03();

	return 0;
}
```

#### 4.6.3 继承中的对象模型

**问题：** 从父类继承过来的成员，哪些属于子类对象中？

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//继承中的对象模型
class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

class Son :public Base
{
private:
	int m_D;
};

void test01()
{
	//父类中所有非静态成员属性都会被子类继承下去
	//父类中私有成员属性被子类继承下去了，但是被编译器隐藏，不可以访问
	Son son;
	cout << "size of son = " << sizeof(son) << endl;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029205505779](https://img.wkeyu.cn/blog/paper/20211029205505.png)

> 总结: 1. 父类中所有非静态成员属性都会被子类继承下去
>
> ​		  2. 父类中私有成员属性被子类继承下去了，但是被编译器隐藏，不可以访问

Tips:  **利用开发人员命令提示工具查看对象模型**

1. 切换到程序所在目录
2. `cl /d1 reportSingleClassLayout类名 文件名`

![image-20211029210148322](https://img.wkeyu.cn/blog/paper/20211029210148.png)

#### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

**继承中的构造和析构顺序：**

+ 先构造父类，再构造子类
+ 析构的顺序和构造相反

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//继承中构造和析构顺序
class Base
{
public:
	Base()
	{
		cout << "父类的构造函数调用" << endl;
	}
	~Base()
	{
		cout << "父类的析构函数调用" << endl;
	}
};

class Son :public Base
{
public:
	Son()
	{
		cout << "子类的构造函数调用" << endl;
	}
	~Son()
	{
		cout << "子类的析构函数调用" << endl;
	}
};

void test01()
{
	//Base base;
	Son son;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029210804540](https://img.wkeyu.cn/blog/paper/20211029210804.png)

#### 4.6.5 继承中同名成员处理方式

**问题：** 当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

+ 访问子类同名成员，直接访问即可
+ 访问父类同名成员，需要加作用域

```cpp
#include<iostream>
#include<string>
using namespace std;

//继承中同名成员处理
class Base
{
public:
	Base()
	{
		m_A = 100;
	}

	void func()
	{
		cout << "Base-func函数调用" << endl;
	}
	void func(int a)
	{
		cout << "Base-func(int a)函数调用" << endl;
	}

public:
	int m_A;
};

class Son :public Base
{
public:
	Son()
	{
		m_A = 200;
	}

	void func()
	{
		cout << "Son-func函数调用" << endl;
	}

public:
	int m_A;
};

//1. 同名成员属性
void test01()
{
	Son s;
	cout << "Son下m_A = " << s.m_A << endl;
	//如果通过子类对象访问父类下的同名成员，需要加作用域
	cout << "Base下m_A = " << s.Base::m_A << endl;
}

//2. 同名成员函数
void  test02()
{
	Son s;
	s.func();
	s.Base::func();
	//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类的所有同名成员函数
	//s.func(100);
	s.Base::func(100);
}

int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211029212209650](https://img.wkeyu.cn/blog/paper/20211029212209.png)

> 总结：
>
> 1. 子类对象可以直接访问到子类中同名成员
> 2. 子类对象加作用域可以访问到父类同名成员
> 3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

#### 4.6.6 继承中同名静态成员处理方式

**问题：** 继承中同名的静态成员在子类对象上如何进行访问？

静态成员与非静态成员出现同名，处理方式一致

+ 访问子类同名成员，直接访问即可
+ 访问父类同名成员，需要加作用域

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//继承中的同名静态成员处理方式
class Base
{
public:
	static int m_A;
	static void func()
	{
		cout << "Base-func函数调用" << endl;
	}
};
int Base::m_A = 100;

class Son :public Base
{
public:
	static int m_A;
	static void func()
	{
		cout << "Son-func函数调用" << endl;
	}
};
int Son::m_A = 200;

//同名静态成员属性
void test01()
{
	//1. 通过对象访问
	cout << "通过对象访问静态成员变量：" << endl;
	Son s;
	cout << "Son下m_A = " << s.m_A << endl;
	cout << "Base下m_A = " << s.Base::m_A << endl;

	//2. 通过类名访问
	cout << "通过类名访问静态成员变量：" << endl;
	cout << "Son下 m_A=" << Son::m_A << endl;
	//第一个::代表通过类名的方式访问，第二个::代表访问父类作用域下
	cout << "Base下 m_A=" << Son::Base::m_A << endl;
}

//同名静态成员函数
void test02()
{
	Son s;
	//1. 通过对象访问
	cout << "通过对象访问静态成员函数" << endl;
	s.func();
	s.Base::func();

	//2. 通过类名访问
	cout << "通过类名访问静态成员函数" << endl;
	Son::func();
	Son::Base::func();
}
int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211029214112807](https://img.wkeyu.cn/blog/paper/20211029214112.png)

> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名)

#### 4.6.7 多继承语法

C++允许一个类继承多个类

语法：`class 子类：继承方式 父类1，继承方式 父类2`

多继承可能引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议使用多继承**

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//多继承语法
class Base1
{
public:
	Base1()
	{
		m_A = 100;
	}
public:
	int m_A;
};

class Base2
{
public:
	Base2()
	{
		m_A = 200;
	}
public:
	int m_A;
};

class Son :public Base1, public Base2
{
public:
	Son()
	{
		m_C = 300;
		m_D = 400;
	}
public:
	int m_C;
	int m_D;
};

void test01()
{
	Son s;
	cout << "sizeof Son = " << sizeof(s) << endl;
	//当父类中出现同名成员，需要加作用域区分
	cout << "Base1下m_A = " << s.Base1::m_A << endl;
	cout << "Base2下m_A = " << s.Base2::m_A << endl;
}

int main()
{
	test01();

	return 0;
}
```

![image-20211029215724032](https://img.wkeyu.cn/blog/paper/20211029215724.png)

> 总结：多继承如果父类出现了同名情况，子类使用时要加作用域

#### 4.6.8 菱形继承

**菱形继承概念：**

​	两个派生类继承同一个父类

​	又有某个类同时继承这两个派生类

​	这种继承被称为菱形继承，或者钻石继承

**典型的菱形继承案例：**

![image-20211029220052630](https://img.wkeyu.cn/blog/paper/20211029220052.png)

**菱形继承问题：**

1. 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性
2. 羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以

**解决方式：**

+ 虚继承  virtual

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//动物类
class Animal
{
public:
	int m_Age;
};

//利用虚继承 解决菱形继承的问题
//继承之前 加上关键字 virtual 变为虚继承
//Animal 称为 虚基类

//羊类
class Sheep :virtual public Animal
{

};

//驼类
class Tuo :virtual public Animal
{

};

//羊驼类
class SheepTuo :public Sheep, public Tuo
{

};

void test01()
{
	SheepTuo st;

	st.Sheep::m_Age = 18;
	st.Tuo::m_Age = 28;
	//当菱形继承，两个父亲拥有相同数据，需要加作用域以区分
	cout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;
	cout << "st.Tuo::m_Age = " << st.Tuo::m_Age << endl;
	
	//虚继承后只有一个数据
	cout << "st.m_Age = " << st.m_Age;

	//这份数据只要有一份就可以，菱形继承导致有两份，资源浪费
}
int main()
{
	test01();

	return 0;
}
```

![image-20211029221715700](https://img.wkeyu.cn/blog/paper/20211029221715.png)

### 4.7 多态

#### 4.7.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分为两类：

+ 静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名
+ 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：

+ 静态多态的函数地址早绑定——编译阶段确定函数地址
+ 动态多态的函数地址晚绑定——运行阶段确定函数地址

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//多态

//动物类
class Animal
{
public:
	//虚函数
    //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了
	virtual void speak()
	{ 
		cout << "动物在说话" << endl;
	}
};

//猫类
class Cat :public Animal
{
public:
	void speak()
	{
		cout << "猫猫在说话" << endl;
	}
};

//狗类
class Dog :public Animal
{
public:
	//重写：函数返回值类型 函数名称 函数参数列表完全相同
	void speak()
	{
		cout << "小狗在说话" << endl;
	}
};

//执行说话的函数
//地址早绑定		在编译阶段确定函数地址
//如果像执行猫说话	需要地址晚绑定

//动态多态满足条件：
//1. 有继承关系
//2. 子类重写父类的虚函数

//动态多态使用
//父类的指针或者引用 执行子类对象	Animal& animal=cat(dog)

void doSpeak(Animal& animal)//Animal& animal=cat(dog)
{
	animal.speak();
}

void test01()
{
	Cat cat;
	Dog dog;
	doSpeak(cat);
	doSpeak(dog);
}

int main()
{
	test01();

	return 0;
}
```

![image-20211030104308718](https://img.wkeyu.cn/blog/paper/20211030104308.png)

**总结：**

多态满足条件：

1. 有继承关系
2. 子类重写父类的虚函数

多态使用条件：

+ 父类的指针或者引用 执行子类对象

-----

**多态原理剖析：**

![image-20211030105330658](https://img.wkeyu.cn/blog/paper/20211030105330.png)

利用vs开发人员命令工具查看：

1. 当父类Animal中speak（）不是虚函数时：

   ![image-20211030110154672](https://img.wkeyu.cn/blog/paper/20211030110154.png)

2. 当父类Animal类speak（）变为虚函数时：

   ![image-20211030105936036](https://img.wkeyu.cn/blog/paper/20211030105936.png)

3. 当子类Cat中speak（）没有重写父类虚函数时：

   ![image-20211030110521541](https://img.wkeyu.cn/blog/paper/20211030110521.png)

4. 当子类Cat中speak（）重写父类虚函数时：

   ![image-20211030110551776](https://img.wkeyu.cn/blog/paper/20211030110551.png)

#### 4.7.2 多态案例——计算器类

 **案例描述：** 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

**多态的优点：**

+ 代码组织结构清晰
+ 可读性强
+ 利于前期和后期的扩展以及维护

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//分别利用普通写法和多态技术实现计算器

//普通写法
class Caculator
{
public:
	int getResult(string oper)
	{
		if (oper == "+")
		{
			return m_Num1 + m_Num2;
		}
		else if (oper == "-")
		{
			return m_Num1 - m_Num2;
		}
		else if (oper == "*")
		{
			return m_Num1 * m_Num2;
		}

		//如果想扩展新的功能，需要修改源码
		//在真实开发中 提倡 开闭原则：对扩展进行开发，对修改进行关闭
	}
public:
	int m_Num1;
	int m_Num2;
};

//多态写法

//实现计算器抽象类
class AbstractCalculator
{
public:
	virtual int getResult()
	{
		return 0;
	}
public:
	int m_Num1;
	int m_Num2;
};

//加法计算器类
class AddCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 + m_Num2;
	}
};
//减法计算器
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 - m_Num2;
	}
};
//乘法计算器
class MulCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 * m_Num2;
	}
};

void test01()
{
	Caculator c;
	c.m_Num1 = 10;
	c.m_Num2 = 5;

	cout << c.m_Num1 << "+" << c.m_Num2 << "=" << c.getResult("+") << endl;
}

void test02()
{
	//多态使用条件
	//父类指针或者引用指向子类对象

	//加法运算
	AbstractCalculator* abc = new AddCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 5;
	cout << abc->m_Num1 << "+" << abc->m_Num2 << "=" << abc->m_Num1 + abc->m_Num2 << endl;
	//堆区开辟的数据用完需要销毁
	delete abc;

	//减法运算
	abc = new SubCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 5;
	cout << abc->m_Num1 << "-" << abc->m_Num2 << "=" << abc->m_Num1 - abc->m_Num2 << endl;
	//堆区开辟的数据用完需要销毁
	delete abc;
}

int main()
{
	test01();
	test02();

	return 0;
}
```

![image-20211030112542236](https://img.wkeyu.cn/blog/paper/20211030112542.png)

> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多

#### 4.7.3 纯虚函数和抽象类

在多态中，通常父类的虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名（参数列表）= 0;`

当类中有了纯虚函数，这个类也称为***抽象类***

**抽象类特点：**

+ 无法实例化对象
+ 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

**示例：**

```cpp
 #include<iostream>
#include<string>
using namespace std;

//纯虚函数和抽象类
class Base
{
public:
	//纯虚函数
	//只要有一个纯虚函数，这个类称为抽象类
	//抽象类特点：
	//1. 无法实例化对象
	//2. 抽象类的子类 必须重写父类的纯虚函数 否则也属于抽象类
	virtual void func() = 0;
};

class Son :public Base
{
public:
	virtual void func()
	{
		cout << "func函数调用" << endl;
	}
};

void test01()
{
	//Base b;	抽象类无法实例化对象
	Base* base = new Son;
	base->func();
}

int main()
{
	test01();

	return 0;
}
```

#### 4.7.4 多态案例而——制作饮品

**案例描述：**

制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料

利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

**代码：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//多态案例二--制作饮品
class AbstractDrinking
{
public:
	//注水
	virtual void Boil() = 0;

	//冲泡
	virtual void Brew() = 0;

	//倒入杯中
	virtual void PourInCup() = 0;

	//加入辅料
	virtual void PutSomething() = 0;

	//制作饮品
	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};

//制作咖啡
class Coffee :public AbstractDrinking
{
public:
	//注水
	virtual void Boil()
	{
		cout << "煮农夫山泉" << endl;
	}

	//冲泡
	virtual void Brew()
	{
		cout << "冲泡咖啡" << endl;
	}

	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入咖啡杯" << endl;
	}

	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入糖" << endl;
	}
};

//制作茶叶
class Tea :public AbstractDrinking
{
public:
	//注水
	virtual void Boil()
	{
		cout << "煮矿泉水" << endl;
	}

	//冲泡
	virtual void Brew()
	{
		cout << "冲泡茶叶" << endl;
	}

	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入茶杯" << endl;
	}

	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入枸杞" << endl;
	}
};

void doWork(AbstractDrinking* abs)
{
	abs->makeDrink();
	delete abs;//释放
}

void test01()
{
	//制作咖啡
	doWork(new Coffee);

	cout << "---------------" << endl;
	//制作茶
	doWork(new Tea);
}
int main()
{
	test01();

	return 0;
}
```

![image-20211030115315211](https://img.wkeyu.cn/blog/paper/20211030115315.png)

#### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为**虚析构**或**纯虚析构**

虚析构和纯虚析构共性：

+ 可以解决父类指针释放子类对象
+ ***都需要具体的函数实现***

虚析构和纯虚析构区别：

+ 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：`virtual ~类名(){}`

纯虚析构语法：`virtual ~类名()=0;`

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//虚析构和纯虚析构
class Animal
{
public:
	Animal()
	{
		cout << "Animal的构造函数调用" << endl;
	}
	//纯虚函数
	virtual void speak() = 0;

	//利用虚析构可以解决	父类指针释放子类对象不干净的问题
	/*virtual ~Animal()
	{
		cout << "Animal的析构函数调用" << endl;

	}*/

	//纯虚析构
	//需要声明，也需要实现
	//有了纯虚析构，该类也属于抽象类
	virtual ~Animal()
	{
		cout << "Animal的纯虚析构调用" << endl;
	}
};

class Cat :public Animal
{
public:
	Cat(string name)
	{
		cout << "Cat的构造函数调用" << endl;
		m_Name = new string(name);
	}

	virtual void speak()
	{
		cout << *m_Name << "小猫在说话" << endl;
	}

	~Cat()
	{
		if (m_Name != NULL)
		{
			cout << "Cat的析构函数调用" << endl;

			//父类指针在析构的时候，不会调用子类的析构函数
			//如果子类中有堆区数据，会造成内存泄漏
			delete m_Name;
			m_Name = NULL;
		}
	}

public:
	string* m_Name;
};

void test01()
{
	Animal* animal = new Cat("Tom");
	animal->speak();
	delete animal;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211030120924290](https://img.wkeyu.cn/blog/paper/20211030120924.png)

> 总结：
>
> 1. 纯虚析构和虚析构就是用来解决通过父类指针释放子类对象
> 2. 如果子类没有堆区数据，可以不写为虚析构或纯虚析构
> 3. 拥有纯虚析构函数的类也属于抽象类

#### 4.7.6 多态案例三——电脑组装

**案例描述：** 电脑主要组成部件为CPU、显卡、内存条

将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件。

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作

**示例：**

```cpp
#include<iostream>
#include<string>
using namespace std;

//电脑组装

//抽象不同零件类
//抽象cpu类
class Cpu
{
public:
	//抽象的计算函数
	virtual void Calculate() = 0;
};
//抽象显卡类
class VideoCard
{
public:
	//抽象的显示函数
	virtual void Display() = 0;
};
//抽象内存内
class Memory
{
public:
	//抽象的存储函数
	virtual void Storage() = 0;
};

//电脑类
class Computer
{
public:
	Computer(Cpu* cpu, VideoCard* vc, Memory* mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	//提供工作的函数
	void work()
	{
		m_cpu->Calculate();
		m_vc->Display();
		m_mem->Storage();
	}

	//提供析构函数 释放3个零件
	~Computer()
	{
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}
		if (m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}

private:
	Cpu* m_cpu;//CPU的零件指针
	VideoCard* m_vc;//显卡的零件指针
	Memory* m_mem;//内存的零件指针
};

//具体厂商
//Intel厂商
class IntelCpu :public Cpu
{
public:
	virtual void Calculate()
	{
		cout << "Intel的CPU开始计算了！" << endl;
	}
};
class IntelVc :public VideoCard
{
public:
	virtual void Display()
	{
		cout << "Intel的显卡开始显示了！" << endl;
	}
};
class IntelMem :public Memory
{
public:
	virtual void Storage()
	{
		cout << "Intel的内存开始存储了！" << endl;
	}
};
//联想厂商
class LenevoCpu :public Cpu
{
public:
	virtual void Calculate()
	{
		cout << "Lenevo的CPU开始计算了！" << endl;
	}
};
class LenevoVc :public VideoCard
{
public:
	virtual void Display()
	{
		cout << "Lenevo的显卡开始显示了！" << endl;
	}
};
class LenevoMem :public Memory
{
public:
	virtual void Storage()
	{
		cout << "Lenevo的内存开始存储了！" << endl;
	}
};

void test01()
{
	//第一台电脑零件
	Cpu* intelCpu = new IntelCpu;
	VideoCard* intelVc = new IntelVc;
	Memory* intelMem = new IntelMem;

	cout << "第一台电脑开始工作！" << endl;
	//创建第一台电脑
	Computer* computer1 = new Computer(intelCpu, intelVc, intelMem);
	computer1->work();
	delete computer1;

	cout << "------------------------------------" << endl;
	cout << "第二台电脑开始工作！" << endl;
	//创建第二台电脑
	Computer* computer2 = new Computer(new LenevoCpu, new LenevoVc, new LenevoMem);
	computer2->work();
	delete computer2;
}
int main()
{
	test01();

	return 0;
}
```

![image-20211030123418629](https://img.wkeyu.cn/blog/paper/20211030123418.png)

## 5. 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过**文件可以将数据持久化**

C++中对文件操作需要包含头文件`<fstream>`

文件类型分为两种：

1. **文本文件**：文件以文本的**ASCII码**形式存储在计算机中
2. **二进制文件：** 文件以文本的**二进制形式**存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类：

1. `ofstream`：写操作
2. `ifstram`：读操作
3. `ftream`：读写操作

### 5.1 文本文件

#### 5.1.1 写文件

写文件步骤如下：

1. 包含头文件

   `#include <fstream>`

2. 创建流对象

   `ofstream ofs;`

3. 打开文件

   `ofs.open("文件路径",打开方式)；`

4. 写数据

   `ofs<<"写入的数据"；`

5. 关闭文件

   `ofs.close();`

----

文件打开方式;

| 打开方式      | 解释                       |
| ------------- | -------------------------- |
| `ios::in`     | 为读文件而打开文件         |
| `ios::out`    | 为写文件而打开文件         |
| `ios::ate`    | 初始位置：文件尾           |
| `ios::app`    | 追加方式写文件             |
| `ios::truc`   | 如果文件存在先删除，再创建 |
| `ios::binary` | 二进制方式                 |

**注意：** 文件打开方式可以配合使用，利用`|`操作符

**例如：** 用二进制方式写文件：`ios::binary | ios:: out`

**示例：**

```cpp
#include<iostream>
#include<string>
#include<fstream>
using namespace std;

//文本文件  写文件


void test01()
{
	//1. 包含头文件	ftream
	//2. 创建流对象
	ofstream ofs;

	//3.指定打开方式
	ofs.open("test.txt", ios::out);

	//4. 写内容
	ofs << "姓名：张三" << endl;
	ofs << "性别：男" << endl;
	ofs << "年龄：18" << endl;

	//5. 关闭文件
	ofs.close;
}
int main()
{
	test01();

	return 0;
}
```

> 总结：
>
> + 文件操作必须包含头文件fstream
> + 读文件可以利用ofstream，或者fstream类
> + 打开文件时候需要指定操作文件路径，以及打开方式
> + 利用<<可以向文件中写数据
> + 操作完毕，关闭文件

####  5.1.2 读文件

读文件和写文件步骤相似，但是读文件获取方式相对较多

读文件步骤如下：

1. 包含头文件

   `#include <fstream>`

2. 创建流对象

   `ifstream ifs;`

3. 打开文件并判断文件是否打开成功

   `ifs.open("文件路径",打开方式)；`

4. 读数据

   四种方式读取

5. 关闭文件

   `ifs.close();`

**示例：**

```cpp
 #include<iostream>
#include<fstream>
#include<string>
using namespace std;

//文本文件	读文件
void test01()
{
	//1. 包含头文件

	//2. 创建流对象
	ifstream ifs;

	//3. 打开文件并判断是否打开成功 
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//4. 读数据
	//第一种方式
	/*char buf[1024] = { 0 };
	while (ifs >> buf)
	{
		cout << buf << endl;
	}*/

	//第二种
	/*char buf[1024] = { 0 };
	while (ifs.getline(buf, sizeof(buf)))
	{
		cout << buf << endl;
	}*/

	//第三种
	/*string buf;
	while (getline(ifs, buf))
	{
		cout << buf << endl;
	}*/

	//第四种
	char c;
	while ((c = ifs.get()) != EOF)//EOF=end of file
	{
		cout << c;
	}

	//5. 关闭文件
	ifs.close();
}

int main()
{
	test01();
	return 0;
}
```

> 总结：
>
> + 读文件可以利用ifstream，或者fstream类
> + 利用is_open函数可以判断文件是否打开成功
> + 最后close关闭文件

### 5.2 二进制文件

以二进制方式对文件进行读写操作

打开方式要指定为`ios::binary`

#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型：`ostream& write(const char* buffer,int len);`

参数解释：字符指针buffer指向内存种一段存储空间。len是读写的字节数 

**示例：**

```cpp
#include<iostream>
#include<fstream>
#include<string>
using namespace std;

//二进制文件	写文件
class Person
{
public:
	char m_Name[64];//姓名
	int m_Age;//年龄
};

void test01()
{
	//1. 包含头文件

	//2. 创建流对象
	ofstream ofs;

	//3. 打开文件
	ofs.open("Person.txt", ios::out | ios::binary);

	//4. 写文件
	Person p = { "张三",18 };
	ofs.write((const char*)&p, sizeof(Person));

	//5. 打开文件
	ofs.close();
}

int main()
{
	test01();

	return 0;
}
```

> 总结：文件输出流对象，可以通过write函数，以二进制方式写数据

#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`istream& read(char *buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数

**示例：**

```cpp
#include<iostream>
#include<fstream>
#include<string>
using namespace std;

class Person
{
public:
	char m_Name[64];//姓名
	int m_Age;//年龄
};

//二进制文件	读文件
void test01()
{
	//1. 包含头文件

	//2. 创建流对象
	ifstream ifs;

	//3. 打开文件	判断文件是否打开成功
	ifs.open("Person.txt", ios::in | ios::binary);

	if (!ifs.is_open())
	{
		cout << "打开文件失败" << endl;
		return;
	}
	//4. 读文件
	Person p;

	ifs.read((char*)&p, sizeof(Person));
	cout << "姓名：" << p.m_Name << "   年龄:" << p.m_Age << endl;

	//5. 关闭文件
	ifs.close();
}
int main()
{
	test01();
	return 0;
}
```

> 总结：文件输入流对象 可以通过read函数，以二进制方式读数据

